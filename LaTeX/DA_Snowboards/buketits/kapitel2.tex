\chapter{Mögliche Performance Optimierungen}
\section{Level Of Detail}
Der Begriff LOD (Level of Detail) bezieht sich auf die Komplexität der 3D Darstellung eines 3D-Models. Das LOD kann mit der Distanz vom Betrachter oder nach Wichtigkeit des Objektes verringert oder erhöht werden. LOD kann die Geschwindigkeit und Effizienz des Renderings erhöhen, indem die Arbeitslast in der Grafikpipeline verringert wird. Diese Performance-Verbesserung wird dadurch erhalten, dass z.B. weniger Vertices gerendert werden müssen. Die verringerte visuelle Qualität ist oft nicht bemerkbar, da Objekte sich dann in erhöhter Distanz befinden oder sich schnell bewegen. LOD wird meistens nur auf Geometriedetails angewendet, jedoch kann dieses Konzept auch anders angewendet werden. Theoretisch kann man auch Shader und Pixelkomplexität basierend auf diesen Parametern abändern. Das sogenannte Mipmapping, welches seit einigen Jahren existiert, kann ebenfalls eine höhere Renderingqualität bieten.

\begin{figure}[h]
	\centering
	\includegraphics[width=11cm]{images/buketits_lod}
	\caption{\cite{_lod_formeshes}}
\end{figure}


\section{Culling}
Beim 3D-Rendering beschreibt der Begriff Culling das frühzeitige Aussortieren von Objekten jeglicher Art, welche nicht zum endgültigen Bild beitragen. Es gibt viele Techniken, die Objekte in verschiedenen Bereichen der Rendering-Pipeline aus zu sortieren. Einige dieser Techniken werden vollständig in Software auf der CPU ausgeführt, andere werden von der Hardware (GPU) unterstützt und wieder andere sind in die Grafikkarte integriert. Es ist hilfreich, alle diese Techniken zu verstehen, um eine gute Leistung zu erzielen. Um viel Rechenkraft zu sparen, ist es wichtig, frühzeitig und in größerem Umfang zu cullen. Wichtig ist auch, dass das Culling an sich, selbst nicht zu viel Leistung und Speicherplatz kostet.
Normalerweise erfolgt das Culling der Engine auf der Draw Call Ebene. Beim Culling werden nicht die einzelnen Triangles gecullt, sondern ganze Objekte. Das bedeutet, dass es sinnvoll sein kann, große Objekte in mehrere Teile aufzuteilen, so dass nicht alle Teile zusammen gerendert werden.


Das Culling ist nochmal ne andere Geschichte auch hier streiten sich die Geister.



Was vom Culling ausgeblendet wird muss auch nicht von der GPU berechnet werden.

Aber Objekte müssen auch Cullingbar sein, ich geb dir mal ein Beispiel:



Mal angenommen du hast ein Wolkenkratzer den du von fast überall aus sehen kannst. Der Gesamte Wolkenkratzer besteht aus 15 Millionen Triangles.

Besteht der Wolkenkratzer aus einem einzigen Objekt, bedeutet das entweder:



1.Das Gesamte Gebäude wird gesehen es werden also 15 Millionen Triangles eingeblendet



oder



2.Das Gebäude wird nicht gesehen du hast also 15 Millionen Triangles weniger.



Nun könntest du auch das innere des Wolkenkratzers separat machen und die Fasadenteile ebenfalls extra.



Die Fassade besteht aus 5 Millionen Polygonen und das innere aus 10 Millionen Polygonen.

Sieht man das Gebäudevon außen so muss nur die Fassade mit 5 Millionen Polygonen angezeigt werden und das innere des Gebäudes bleibt ausgeblendet und wird nur Raum für Raum eingeblendet wenn du das Gebäude betrittst.



Culling ist also nicht einfach nur eine Funktion, sondern man muss sich auch überlegen wie man die Meshes sinnvoll aufteilt damit komplexe Modelle sinnvoll ein oder ausgeblendet werden.



Hier können mehr Objekte manchmal performanter sein als riesige Meshes.



Durch LODs kann man das nun noch weiter aufsplitten und performanter machen.
\cite{_cryengine_culling}

\subsection{Frustum Culling}
Frustrum culling ist eine wichtige Technik, welche in so gut wie jeder ernstzunehmenden Engine vorhanden ist. Die Grundlage des Frustrum cullings ist, Objekte, welche sich nicht in der view frustrum pyramid befinden (also nicht gesehen werden und keinen Einfluss auf das endgültige Bild haben) nicht zu rendern und somit Rechenleistung zu sparen.
\cite{_cryengine_culling}

\subsection{Occlusion Culling}
Occlusion culling überprüft ob Objekte oder auch triangles von anderen verdeckt werden und rendert diese dann nicht. Diese Technik ist besonders bei Szenen mit hoher Tiefenkomplexität äußerst wichtig und kann zu erheblichen Performance Einsparungen führen.
\cite{_cryengine_culling}

\begin{figure}[h]
	\centering
	\includegraphics[width=12cm]{images/buketits_frustrum}
	\caption{Zeigt view frustrum pyramid 1.ohne Culling, 2.mit frustrum culling, 3.mit frustrum und occlusion culling\cite{_culling}}
\end{figure}

\subsection{Backface Culling}
Backface culling ist mittlerweile ein Standardfeature welches die Ausrichtung der triangles eines meshes überprüft und damit festlegt ob diese gerendert werden sollen.
\cite{_cryengine_culling}

\section{Draw Calls}
Es gibt dinge die berechnet die CPU und es gibt dinge die Berechnet die GPU.
Aufgaben die die CPU an die GPU weiter gibt, nennt man Drawcalls.
Man kann sich ein Drawcall also wie ein Brief vorstellen das die CPU an die GPU schickt.
Es Gilt: Umso mehr Brief die CPU an die GPU versendet, umso mehr Briefe muss die GPU öffnen und lesen.
Das Öffnen, dauert hierbei immer länger als das Lesen.
Tust du also Meshes miteinander verbinden, werden es zwar weniger Briefe aber es gibt mehr zu lesen. (Da die Informationen größer sind)
Aber wie gesagt, lieber mehr lesen als viele Briefe.
Drawcalls werden aber nicht nur von Meshes verursacht sondern von allem was deine GPU Berechnet da kommen zb auch Schatten und Reflektions Berechnungen usw dazu.
Dafür gibts leider auch kein Patent Rezept und wo sagen kann, wenn du es so machst, dann machst du es richtig. Es kommt immer darauf an.

Das Problem ist auch:
Auch wenn du Meshes verbinden tust, wird die FBX file immer größer. .Ein IPAD kann nur Meshes ich glaube mit bis zu 2GB lesen. Sind deine Meshes größer hagelt es Fehlermeldungen beim kompilieren. Keine Ahnung wo und ob es beim PC ähnliche Begrenzungen gibt.
Aber du kannst eben an eine Grafikkarte keine 10 Terrabyte große Information schicken.

\subsection{Dynamic Draw call batching}
Die Unity-Engine stapelt draw calls von mehreren GameObjects, welche das gleiche Material verwenden. Somit wird die Anzahl der draw calls reduziert und die Last auf der Grafikkarte verringert. Die besten Ergebnisse können erzielt werden, indem das Selbe Material auf möglichst viele Objekte angewandt wird. Um diese Technik anzuwenden muss man jedoch auf ein paar Regulierungen achten. Mesh Renderer, Trail Renderer, Line Renderer, Particle Systems und Sprite Renderer unterstützen draw call batching. Andere rendering components unterstützen diese Technik nicht. Abgesehen davon, muss die rendering component die selbe sein. Das heißt, dass z.B. Mesh Renderer und Trail Renderer nicht gebatcht werden. Sollte man mehrere Materialien verwenden, ist es auch möglich die gleiche Textur zu einzusetzen und damit Performance zu sparen. Dieser Vorgang heißt texture atlasing.

\subsection{Static Draw call batching}
Unity can perform static batching at build time and at runtime. As a general rule, if the GameObjects
exist in a scene
before you build your application, use the Editor to batch your GameObjects at build time. If you create the GameObjects and their meshes at runtime, use the runtime API.

When you use the runtime API, you can change the transform properties of the root of a static batch. This means that you can move, rotate, or scale the entire combination of meshes that make up a static batch. You can’t change the transform properties of the individual meshes.

To use static batching for a set of GameObjects, the GameObjects must be eligible for static batching. In addition to the criteria described in the common usage information, make sure that:

The GameObject is active.
The GameObject has a Mesh Filter
component, and that component is enabled.
The Mesh Filter component has a reference to a Mesh.
The mesh is read/write enabled.
The mesh has a vertex count greater than 0.
The mesh has not already been combined with another Mesh.
The GameObject has a Mesh Renderer
component, and that component is enabled.
The Mesh Renderer component does not use any Material with a shader
that has the DisableBatching tag set to true.
Meshes you want to batch together use the same vertex attributes. For example Unity can batch meshes that use vertex position, vertex normal, and one UV with one another, but not with meshes that use vertex position, vertex normal, UV0, UV1, and vertex tangent.

\cite{_drawcallbatching}

\section{Object Pooling}
Wenn GameObjects schnell erstellt und gelöscht werden müssen, ist Object Pooling ist eine gute Technik, um Projekte zu optimieren und die CPU-Last zu verringern. Object Pooling ist ein Design-Pattern, bei welchem die benötigten Objekte bereits vor dem Start des Spiels erstellt und in ein „Zwischenlager“ geschoben werden. Bei Anwendung werden diese dann aus dem Lager geholt und anstatt diese Objekte nach Gebrauch zu zerstören, werden diese dann wieder ins Lager verschoben. Bei manchen Anwendungsfällen erhöht Object Pooling die Performance erheblich. Ein gutes Beispiel wären z.B. Projektile in einem Top-Down-Shooter.
\cite{_objectpooling}

\section{Coroutines vs Update}
In Unity werden sowohl Coroutines als auch die Update-Methode verwendet, um den Zustand eines Spiels oder einer Anwendung im Laufe der Zeit zu aktualisieren. Sie funktionieren jedoch auf leicht unterschiedliche Weise, was sich auf ihre Leistungsmerkmale auswirken kann. Die Update-Methode ist eine eingebaute Unity-Funktion, die einmal pro Frame aufgerufen wird und typischerweise zur Aktualisierung der Positionen, Geschwindigkeiten und anderer Eigenschaften von Objekten in der Szene verwendet wird. Diese Methode wird von Unity automatisch aufgerufen. Coroutines sind eine Möglichkeit, benutzerdefinierte Iterationen zu erstellen, die gleichzeitig mit der Update-Methode ausgeführt werden. Eine Coroutine ist im Wesentlichen eine Funktion, die angehalten und zu einem späteren Zeitpunkt wieder aufgenommen werden kann. Coroutines können verwendet werden, um einen Prozess durchzuführen, welcher über einen bestimmten Zeitraum hinweg erfolgen soll, z. B. das Verschieben eines Objekts an eine neue Position oder das Abspielen einer Animation. Coroutines sind weniger performance-effizient als die Update-Methode. Wenn der Zustand eines Objekts sich einmal pro Frame aktualisieren soll, ist es in der Regel am besten, die Update-Methode zu verwenden. Dadurch wird sichergestellt, dass die Änderungen mit dem Rest des Spiels synchronisiert sind und es benötigt weniger Rechenleistung. Wenn man eine Funktion immer wieder pausieren muss und diese vielleicht sogar in anderen Abständen, als jeden Frame, aufrufen will, dann ist eine Coroutine die bessere Wahl.
\cite{dickinson2015unity}

\section{Static and Dynamic Colliders}
Static Collider in der Unity-Engine sind nicht die Objekte, welche den Static Flag angehakt haben, sondern Objekte welche keinen Rigidbody haben. Objekte auf welchen die Rigidbody Komponente ist, gelten als Dynamic Collider. Static Collider werden, anders als die Dynamic Collider, in eine andere optimierte Struktur kombiniert.

Static Collider
A static collider is a GameObject that has a Collider but no Rigidbody. Static colliders are mostly used for level geometry which always stays at the same place and never moves around. Incoming Rigidbody objects collide with static colliders but don’t move them.

In particular cases, the physics engine optimizes for static colliders that never move. For instance, a vehicle resting on top of a static collider remains asleep even if you move this static collider. You can enable, disable, or move static colliders in runtime without specially affecting the physics engine computation speed. Also, you can safely scale a static Mesh Collider as long as the scale is uniform (not skewed).

Rigidbody Collider
This is a GameObject with a Collider and a normal, non-kinematic Rigidbody attached. Rigidbody colliders are fully simulated by the physics engine and can react to collisions and forces applied from a script. They can collide with other objects (including static colliders) and are the most commonly used Collider configuration in games that use physics.

Kinematic Rigidbody Collider
This is a GameObject with a Collider and a kinematic Rigidbody attached (ie, the IsKinematic property of the Rigidbody is enabled). You can move a kinematic rigidbody object from a script by modifying its Transform Component
but it will not respond to collisions and forces like a non-kinematic rigidbody. Kinematic rigidbodies should be used for colliders that can be moved or disabled/enabled occasionally but that should otherwise behave like static colliders. An example of this is a sliding door that should normally act as an immovable physical obstacle but can be opened when necessary. Unlike a static collider, a moving kinematic rigidbody will apply friction to other objects and will “wake up” other rigidbodies when they make contact.

Even when immobile, kinematic rigidbody colliders have different behavior to static colliders. For example, if the collider is set to as a trigger then you also need to add a rigidbody to it in order to receive trigger events in your script. If you don’t want the trigger to fall under gravity or otherwise be affected by physics then you can set the IsKinematic property on its rigidbody.

A Rigidbody component can be switched between normal and kinematic behavior at any time using the IsKinematic property.

A common example of this is the “ragdoll” effect where a character normally moves under animation but is thrown physically by an explosion or a heavy collision. The character’s limbs can each be given their own Rigidbody component with IsKinematic enabled by default. The limbs move normally by animation until IsKinematic is switched off for all of them and they immediately behave as physics objects. At this point, a collision or explosion force will send the character flying with its limbs thrown in a convincing way.
\cite{_staticCollider}

\section{Verschiedene Arten von Collidern}
In work
\begin{figure}[h]
	\centering
	\includegraphics[width=11cm]{images/buketits_collidertypes}
	\caption{Verschiedene Arten von Collidern}
\end{figure}
\cite{dickinson2015unity}