\chapter{Mögliche Performance Optimierungen}
\section{Level Of Detail}
Der Begriff LOD (Level of Detail) bezieht sich auf die Komplexität der 3D Darstellung eines 3D-Models. Das LOD kann mit der Distanz vom Betrachter oder nach Wichtigkeit des Objektes verringert oder erhöht werden. LOD kann die Geschwindigkeit und Effizienz des Renderings erhöhen, indem die Arbeitslast in der Grafikpipeline verringert wird. Diese Performance-Verbesserung wird dadurch erhalten, dass z.B. weniger Vertices gerendert werden müssen. Die verringerte visuelle Qualität ist oft nicht bemerkbar, da Objekte sich dann in erhöhter Distanz befinden oder sich schnell bewegen. LOD wird meistens nur auf Geometriedetails angewendet, jedoch kann dieses Konzept auch anders angewendet werden. Theoretisch kann man auch Shader und Pixelkomplexität basierend auf diesen Parametern abändern. Das sogenannte Mipmapping, welches seit einigen Jahren existiert, kann ebenfalls eine höhere Renderingqualität bieten.

\begin{figure}[h]
	\centering
	\includegraphics[width=11cm]{images/buketits_lod}
	\caption{\cite{_lod_formeshes}}
\end{figure}


\section{Culling}
Beim 3D-Rendering beschreibt der Begriff Culling das frühzeitige Aussortieren von Objekten jeglicher Art, welche nicht zum endgültigen Bild beitragen. Es gibt viele Techniken, die Objekte in verschiedenen Bereichen der Rendering-Pipeline aus zu sortieren. Einige dieser Techniken werden vollständig in Software auf der CPU ausgeführt, andere werden von der Hardware (GPU) unterstützt und wieder andere sind in die Grafikkarte integriert. Es ist hilfreich, alle diese Techniken zu verstehen, um eine gute Leistung zu erzielen. Um viel Rechenkraft zu sparen, ist es wichtig, frühzeitig und in größerem Umfang zu cullen. Wichtig ist auch, dass das Culling an sich, selbst nicht zu viel Leistung und Speicherplatz kostet.
Normalerweise erfolgt das Culling der Engine auf der Draw Call Ebene. Beim Culling werden nicht die einzelnen Triangles gecullt, sondern ganze Objekte. Das bedeutet, dass es sinnvoll sein kann, große Objekte in mehrere Teile aufzuteilen, so dass nicht alle Teile zusammen gerendert werden.
\cite{_cryengine_culling}

\subsection{Frustum Culling}
Frustrum culling ist eine wichtige Technik, welche in so gut wie jeder ernstzunehmenden Engine vorhanden ist. Die Grundlage des Frustrum cullings ist, Objekte, welche sich nicht in der view frustrum pyramid befinden (also nicht gesehen werden und keinen Einfluss auf das endgültige Bild haben) nicht zu rendern und somit Rechenleistung zu sparen.
\cite{_cryengine_culling}

\subsection{Occlusion Culling}
Occlusion culling überprüft ob Objekte oder auch triangles von anderen verdeckt werden und rendert diese dann nicht. Diese Technik ist besonders bei Szenen mit hoher Tiefenkomplexität äußerst wichtig und kann zu erheblichen Performance Einsparungen führen.
\cite{_cryengine_culling}

\begin{figure}[h]
	\centering
	\includegraphics[width=12cm]{images/buketits_frustrum}
	\caption{Zeigt view frustrum pyramid 1.ohne Culling, 2.mit frustrum culling, 3.mit frustrum und occlusion culling\cite{_culling}}
\end{figure}

\subsection{Backface Culling}
Backface culling ist mittlerweile ein Standardfeature welches die Ausrichtung der triangles eines meshes überprüft und damit festlegt ob diese gerendert werden sollen.
\cite{_cryengine_culling}


\section{Draw call batching}
Die Unity-Engine stapelt draw calls von mehreren GameObjects, welche das gleiche Material verwenden. Somit wird die Anzahl der draw calls reduziert und die Last auf der Grafikkarte verringert. Die besten Ergebnisse können erzielt werden, indem das Selbe Material auf möglichst viele Objekte angewandt wird. Um diese Technik anzuwenden muss man jedoch auf ein paar Regulierungen achten. Mesh Renderer, Trail Renderer, Line Renderer, Particle Systems und Sprite Renderer unterstützen draw call batching. Andere rendering components unterstützen diese Technik nicht. Abgesehen davon, muss die rendering component die selbe sein. Das heißt, dass z.B. Mesh Renderer und Trail Renderer nicht gebatcht werden. Sollte man mehrere Materialien verwenden, ist es auch möglich die gleiche Textur zu einzusetzen und damit Performance zu sparen. Dieser Vorgang heißt texture atlasing.
\cite{_drawcallbatching}

\section{Object Pooling}
Wenn GameObjects schnell erstellt und gelöscht werden müssen, ist Object Pooling ist eine gute Technik, um Projekte zu optimieren und die CPU-Last zu verringern. Object Pooling ist ein Design-Pattern, bei welchem die benötigten Objekte bereits vor dem Start des Spiels erstellt und in ein „Zwischenlager“ geschoben werden. Bei Anwendung werden diese dann aus dem Lager geholt und anstatt diese Objekte nach Gebrauch zu zerstören, werden diese dann wieder ins Lager verschoben. Bei manchen Anwendungsfällen erhöht Object Pooling die Performance erheblich. Ein gutes Beispiel wären z.B. Projektile in einem Top-Down-Shooter.
\cite{_objectpooling}

\section{Coroutines vs Update}
In Unity werden sowohl Coroutines als auch die Update-Methode verwendet, um den Zustand eines Spiels oder einer Anwendung im Laufe der Zeit zu aktualisieren. Sie funktionieren jedoch auf leicht unterschiedliche Weise, was sich auf ihre Leistungsmerkmale auswirken kann. Die Update-Methode ist eine eingebaute Unity-Funktion, die einmal pro Frame aufgerufen wird und typischerweise zur Aktualisierung der Positionen, Geschwindigkeiten und anderer Eigenschaften von Objekten in der Szene verwendet wird. Diese Methode wird von Unity automatisch aufgerufen. Coroutines sind eine Möglichkeit, benutzerdefinierte Iterationen zu erstellen, die gleichzeitig mit der Update-Methode ausgeführt werden. Eine Coroutine ist im Wesentlichen eine Funktion, die angehalten und zu einem späteren Zeitpunkt wieder aufgenommen werden kann. Coroutines können verwendet werden, um einen Prozess durchzuführen, welcher über einen bestimmten Zeitraum hinweg erfolgen soll, z. B. das Verschieben eines Objekts an eine neue Position oder das Abspielen einer Animation. Coroutines sind weniger performance-effizient als die Update-Methode. Wenn der Zustand eines Objekts sich einmal pro Frame aktualisieren soll, ist es in der Regel am besten, die Update-Methode zu verwenden. Dadurch wird sichergestellt, dass die Änderungen mit dem Rest des Spiels synchronisiert sind und es benötigt weniger Rechenleistung. Wenn man eine Funktion immer wieder pausieren muss und diese vielleicht sogar in anderen Abständen, als jeden Frame, aufrufen will, dann ist eine Coroutine die bessere Wahl.
\cite{dickinson2015unity}

\section{Static and Dynamic Colliders}
Static Collider in der Unity-Engine sind nicht die Objekte, welche den Static Flag angehakt haben, sondern Objekte welche keinen Rigidbody haben. Objekte auf welchen die Rigidbody Komponente ist, gelten als Dynamic Collider. Static Collider werden, anders als die Dynamic Collider, in eine andere optimierte Struktur kombiniert.
\cite{dickinson2015unity}

\section{Verschiedene Arten von Collidern}

\cite{dickinson2015unity}